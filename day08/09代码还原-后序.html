<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 根据前序结果和中序结果还原二叉树并且进行后序遍历
    var qian=['A','C','F','G','B','D','E']
    var zhong=['F','C','G','A','D','B','E']
    function Node(value) {
        this.value=value
        this.left=null
        this.right=null
    }
    // 还原二叉树
    function fun(qian,zhong) {
        if (qian==null||zhong==null||qian.length==0||zhong.length==0||qian.length!=zhong.length) return;
        // 二叉树的根节点
        var root=new Node(qian[0])

        // 中序遍历的根节点在中序遍历结果的正中间，找到根节点在中序排序中的索引
        var index=zhong.indexOf(root.value)

        // 前序遍历的左子树
        var qianLeft=qian.slice(1,index+1)

        // 前序遍历的右子树
        var qianRight=qian.slice(index+1,qian.length)


        // 中序遍历的左子树
        var zhongLeft=zhong.slice(0,index)
        // 中序遍历的右子树
        var zhongRight=zhong.slice(index+1,zhong.length)


        root.left=fun(qianLeft,zhongLeft)
        root.right=fun(qianRight,zhongRight)

        return root;
    }

    var root=fun(qian,zhong)
    console.log(root)

    function funBian(root){
        if(root == null) return
        funBian(root.left)   // 输出左边
        funBian(root.right)   // 输出右边
        console.log(root.value);   //先输出自己
    }
    funBian(root)
</script>
</body>
</html>
